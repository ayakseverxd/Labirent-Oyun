<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Labirent Oyunu</title>
	<style>
		body {
			font-family: Arial, sans-serif;
		}

		.maze {
			display: grid;
			grid-template-columns: repeat(40, 30px);
			grid-template-rows: repeat(40, 30px);
			justify-content: center;
		}

		.cell {
			width: 30px;
			height: 30px;
			border: 1px solid #000;
			background-color: #fff;
		}

		.start {
			background-color: green;
		}

		.end {
			background-color: red;
		}
		.player {
			background-color: blue;
		}
		.obstacle {
			background-color: pink;
		}
		.modal {
			display: none;
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.5);
			justify-content: center;
			align-items: center;
		}

		.modal-content {
			background-color: #fff;
			padding: 20px;
			border-radius: 5px;
		}

		.reset-button {
			display: block;
			margin-top: 10px;
		} 
		h1{
			text-align: center;
		}
	</style>
</head>
<body>
	<h1>Labirent Oyunu</h1>
	<div class="maze" id="maze"></div>
		<div id="message"></div>
		<!-- Modal -->
	<div id="resetModal" class="modal">
		<div class="modal-content">
			<p>Oyunu sıfırlamak istediğinize emin misiniz?</p>
			<button class="reset-button" id="confirmReset">Evet</button>
			<button class="reset-button" id="cancelReset">Hayır</button>
		</div>
	</div>

	<script>
		const mazeContainer = document.getElementById('maze');
		const messageElement = document.getElementById('message');
		// Labirent boyutları
		const rows = 40;
		const cols = 40
		// Başlangıç ve bitiş noktaları
		const startCell = [0, 0];
		const endCell = [39, 39];
		const maze = [];

		let playerPosition = [...startCell];
		// Labirenti oluştur
		for (let row = 0; row < rows; row++) {
			maze.push([]);
			for (let col = 0; col < cols; col++) {
				const cell = document.createElement('div');
				cell.classList.add('cell');
				if (row === startCell[0] && col === startCell[1]) {
					cell.classList.add('start');
				}
				if (row === endCell[0] && col === endCell[1]) {
					cell.classList.add('end');
				}

				// bu hucrelerin her zaman duvar olmasi lazim
				if(row % 2 === 1 && col % 2 === 1){
					cell.classList.add("obstacle");
				}
				mazeContainer.appendChild(cell);
				maze[row].push(cell);
			}
		}
		let playerCell = maze[playerPosition[0]][playerPosition[1]];
		playerCell.classList.add('player');

		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		async function generateMaze() {
			const stack = [];
			const visited = [];
			let endReached = false;
			for(let y=0; y<rows; y++){
				visited.push(new Array(cols).fill(false));
			}

			function isValid(x, y) {
				return x >= 0 && x < cols && y >= 0 && y < rows && !visited[y][x];
			}

			stack.push(startCell);
			
			while (stack.length) {
				const neighbors = [];

				const currentCell = stack.pop();
				const [x, y] = currentCell;

				if (isValid(x - 2, y)) neighbors.push([x - 2, y]);
				if (isValid(x + 2, y)) neighbors.push([x + 2, y]);
				if (isValid(x, y - 2)) neighbors.push([x, y - 2]);
				if (isValid(x, y + 2)) neighbors.push([x, y + 2]);

				if (!neighbors.length){
					continue;
				}

				stack.push(currentCell);
				const newCell = neighbors[Math.floor(Math.random() * neighbors.length)];
				const [newX, newY] = newCell;
				const newCellElem = maze[newY][newX];

				const wallX = x + (newX - x) / 2;
				const wallY = y + (newY - y) / 2;
				const wallElem = maze[wallY][wallX];

				visited[newY][newX] = true;
				stack.push(newCell);
				if (Math.random() > 0.5 && !newCellElem.classList.contains('start') && !newCellElem.classList.contains('end')) {
					wallElem.classList.add('obstacle');
				}

				await sleep(10);
			}

			console.log("done");
		}
		
		generateMaze();
	</script>
</body>
</html>